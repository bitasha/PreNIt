#rmat: rating matrix m*n
#usersequence: a list of array such that  userSeq[[i]] contains items that are rated by i-th user 
#       (is generated by makeUserseq function)

#rl: length of recommendation list (NDCG@rl)
#trl : length of traiing profile of each user (i.e. UPL)
#nl:  length of neighborhood size (typically set to 100)
#direc: the direction of check point recorder 
#trdirec: the direction for training file if available 
#first run : a logic variable to indicate if the evaluation should be initialized or it should be continued based on the check point file
#dampingFactor: the damping factor for graph-based similarity measure
#trainflag:a logical variable to indicate training set  should be generated randomly(0) or load from file(1)
#smet: type of semantic analysis: smet=1: user-based, smet=2: P-ReGRank, smet=3: R-ReGRank

rankEvaluation_Yu_PReNIt<-function(rmat,userSeq,rl=c(1,3,5,10),trl,direc,firstRun,trainflag=0,damping=0.85,trdirec,smet){
  
  userLength= calUserLength(userSeq);
  NDCG=matrix(0,length(trl),length(rl));  
  count=matrix(0,length(trl),length(rl));
  param=c(1,1,0,0)
  tt=0;
  tt2=0;
  if(firstRun==0){
    direcFile=read.csv(direc)
    direcFile=direcFile[,-1]
    param=as.numeric(direcFile[1,]);          st=2;     end=st+length(trl)-1;
    NDCG=data.matrix(direcFile[st:(end),]);     st=end+1; end=st+length(trl)-1;
    count=data.matrix(direcFile[st:end,]);  
    userLength= calUserLength(userSeq); tt=0;
    tt2=param[4];
  }
  
  for(w in param[1]:length(trl)){            
    j=trl[w]
    t=Yu_prepareData(rmat,j+max(rl),userSeq);
    userSeq=t@us;
    rmat=t@rmat2;
    ic=ncol(rmat)
    for(i in param[2]:1){
      #trList and testListindices of user in train and tes
      testSet= 1:nrow(rmat);
      trList=c(1:nrow(rmat));
      tr=trList_random(userSeq,j,testSet); 
      if(trainflag==1){
        x=read.csv(trdirec);x=x[,-1]
        tr=lapply(seq_len(nrow(x)),function(i) as.numeric(x[i,]))
      }else{
        writeTrain(tr,trList,trdirec); 
      }
      trMat=makeTrainMat(tr,rmat);
      
      trs=makeTrSPlitList(tr,trMat,1:ic);
      t333<-system.time(RateCom<-Prep(trs = trs,trMat));
      preftr=makeTrList(RateCom,ncol(rmat));
      t<-system.time(l<-make2LGraph_choiceContexGeneral_Ricci2_itembased_winner(preftr,ic = ic));
      g=graph.edgelist(l[,1:2],directed=F);
      nt=(length(tr)*ic+ic)-vcount(g)
      g=add.vertices(g,nt);
      g=set.vertex.attribute(g,name = "id",1:vcount(g),value = 1:vcount(g));
      
      t<-t+system.time(l2<-make2LGraph_choiceContexGeneral_Ricci2_itembased_looser(preftr,ic = ic));
      g2=graph.edgelist(l2[,1:2],directed=F);
      nt2=(length(tr)*ic+ic)-vcount(g2)
      g2=add.vertices(g2,nt2);
      g2=set.vertex.attribute(g2,name = "id",1:vcount(g2),value = 1:vcount(g2));
      
      uidIndex=rep(0,vcount(g));
      wIndex=rep(0,vcount(g));
      lIndex=rep(0,vcount(g2));
      nr=length(tr);
      for(ind in 1:nr){
        r=((ind-1)*ic+1):(ind*ic)
        uidIndex[r]=ind;
      }
      
      for(ind in 1:ic){
        r=nr*ic+ind
        wIndex[r]=ind;
        lIndex[r]=ind;
      }
      g=set.vertex.attribute(g,"uid",1:vcount(g),uidIndex);
      g=set.vertex.attribute(g,"winner",1:vcount(g),wIndex);
      g=set.vertex.attribute(g,"looser",1:vcount(g),lIndex);
      g2=set.vertex.attribute(g2,"uid",1:vcount(g2),uidIndex);
      g2=set.vertex.attribute(g2,"winner",1:vcount(g2),wIndex);
      g2=set.vertex.attribute(g2,"looser",1:vcount(g2),lIndex);
      
      g1=g;
      g=g-(which(degree(g)==0));
      g2=g2-(which(degree(g2)==0));
      
      wind=get.vertex.attribute(g,"winner",1:vcount(g))
      lind=get.vertex.attribute(g2,"looser",1:vcount(g2))
      uind1=get.vertex.attribute(g,"uid",1:vcount(g))
      uind2=get.vertex.attribute(g2,"uid",1:vcount(g2))
      
      wi=array(list(),ic)
      li=array(list(),ic)
      for(ind in 1:ic){
        wi[[ind]]=which(wind==ind)
        li[[ind]]=which(lind==ind)
      }
     
      
      
      
      for(uid in (param[3]+1):length(testSet)){
        if((uid%%50)==0)
          gc(T);
        tp={};
        for(h in 1:length(tr[[testSet[[uid]]]])){
          tp=c(tp,which(userSeq[[testSet[uid]]]==tr[[uid]][h]))
        }
        ts=userSeq[[testSet[uid]]][-tp];
        
        sh=1;
        
        #tt=tt+system.time(f<-makeGraphMat3L(g,uid,tr,ts ,rmat =rmat));
        if(!is.null(preftr[[uid]])){
          t<-t+system.time(f1<-ranking_winner(g = g,ic = ic,uid = uid,wi = wi,li = li,damping=0.85));    
          t<-t+system.time(f2<-ranking_looser(g = g2,ic = ic,uid = uid,wi = wi,li = li,damping=0.85));  
          #  f2<-ranking_user(g = g3,ic = ic,uid = uid,wi = wi,li = li,damping=0.85); 
          t2<-system.time(f<-f1-f2)
          #f=f1-f2;
        }else{
          f=rep(0,ic);
        }
        #tt2=tt2+system.time(f<-pathrank(trans,id = uid,nrow(rmat),ncol(rmat)));
        
        for(d in 1:length(rl)){
          topK=rl[d];
          r=order(f,decreasing=T);
          r=intersect(r,ts);
          recomList=r[1:topK];
          count[w,d]=count[w,d]+1;
          NDCG[w,d]=NDCG[w,d]+calNDCG(f[ts],rmat[testSet[uid],ts],topK);
        }
          if(uid%%50==0){        
            print(c(uid,NDCG/count))
            checkRes=rbind(c(w,i,uid,tt2[1]),NDCG,count);
            write.csv(checkRes,direc);
          }
      }
      
      checkRes=rbind(c(w,i,uid,tt2[1]),NDCG,count);
      
      write.csv(checkRes,direc);
      
    }
    print("NDCG")
    print(NDCG/count)
    print(c("tt",tt));
    # prec=prec/(count);    
    # reca=reca/(count);
    # NDCG=NDCG/(count);
    
  }    
  
  ev=setClass("ev",slots=c("NDCGALL","count","t1"));
  evt=new("ev",NDCGALL=NDCG/count,count=count,t1=tt2);                        
  return(evt)
}
library(igraph)

#This function return the graph that connect users to their winning items (i.e. WNet)
   #tr: is the array list in which i-th element contains the pairwise preference matrix of i-th user
   # ic: the number of column in rating matrix (i.e. the total number of items)
make2LGraph_choiceContexGeneral_Ricci2_itembased_winner<-function(tr,ic) {
  print("constructing graph")
  l = rep(0, 2)
  count = 1
  countp = 1
  nr=length(tr)
  t2 = matrix(0, 5000, 2)
  context=array(list(),0)
  m=0;
  for(k in 1:length(tr)){
    if(!is.null(tr[[k]]))
      m=m+floor(1*nrow(summary(tr[[k]])))
  }
  #m=floor(0.2*m)
  l = matrix(0,m,3);
  
  for (k in 1:length(tr)) {
    uid=k
    if(k%%1000==0)
      print(k)
    if(!is.null(tr[[k]])){
      data=summary(tr[[k]]);
      data=data[sample(1:nrow(data),floor(1*nrow(data))),]
      user=k;
      
      t3 = matrix(0,nrow(data),3);
      count=1;
      
      for(i in 1:nrow(data)){
        
        item1=data[i,1];
        item2=data[i,2];
        value=data[i,3];
        if(value<0){
          tmp=item1;
          item1=item2;
          item2=tmp;
          value=-value;
        }
        h1=(uid-1)*ic+item2;
        h2=nr*ic+(item1);
        t3[count,]=c(h1,h2,value)
        #t3[count,]=c(user,item2+nr,item1+nr,-value)
        
        count=count+1
      }
      countp2=(countp+(nrow(data)))-1
      l[(countp:countp2),]=unique(t3)
      countp=countp2+1;
    }
  }
  print("L3")
  #l=unique(t3[,1:4])
  return(l);
}
                  
#This function return the graph that connect users to their losing items (i.e. LNet)
   #tr: is the array list in which i-th element contains the pairwise preference matrix of i-th user
   # ic: the number of column in rating matrix (i.e. the total number of items)
 #Note that LNet is constructed in the reforemed shape that is compatible with MemoRank (i.e. Preposition 1 in the paper)

make2LGraph_choiceContexGeneral_Ricci2_itembased_looser<-function(tr,ic) {
  print("constructing graph")
  l = rep(0, 2)
  count = 1
  countp = 1
  nr=length(tr)
  t2 = matrix(0, 5000, 2)
  context=array(list(),0)
  m=0;
  for(k in 1:length(tr)){
    if(!is.null(tr[[k]]))
      m=m+floor(1*nrow(summary(tr[[k]])))
  }
  #m=1*m;
  l = matrix(0,m,3);
  
  for (k in 1:length(tr)) {
    uid=k
    if(k%%1000==0)
      print(k)
    if(!is.null(tr[[k]])){
      data=summary(tr[[k]]);
      data=data[sample(1:nrow(data),floor(1*nrow(data))),]
      user=k;
      
      t3 = matrix(0,nrow(data),3);
      count=1;
      
      for(i in 1:nrow(data)){
        
        item1=data[i,1];
        item2=data[i,2];
        value=data[i,3];
        if(value<0){
          tmp=item1;
          item1=item2;
          item2=tmp;
          value=-value;
        }
        h1=(uid-1)*ic+item1;
        h2=nr*ic+(item2);
        t3[count,]=c(h1,h2,value)
        #t3[count,]=c(user,item2+nr,item1+nr,-value)
        
        count=count+1
      }
      countp2=(countp+(nrow(data)))-1
      l[(countp:countp2),]=unique(t3)
      countp=countp2+1;
    }
  }
  print("L3")
  #l=unique(t3[,1:4])
  return(l);
}
 #This fuction scores items based on their weighted similaity to the winning items of the target user
  #g: reformed shape of WNet constructed by the abov functions 
  #uid: the id of the target user
  #wi: the list of winning side of items in the reformed WNet graph
  #Li: the list of losiing side of items in the reformed WNet graph
                  
ranking_winner<-function(g,uid,ic,wi,li,damping=0.85){
  #g=set.vertex.attribute(g,name = "id",1:vcount(g),value = 1:vcount(g));
  #g=g-setdiff(g,which(degree(g)==0));
  r=which(get.vertex.attribute(g,"uid")==uid);
  m=degree(g,r);
  pp=rep(0,vcount(g));
  pp[r]=m/sum(m);
  p=page.rank(g,personalized = pp,damping = damping)$vector;
  score=rep(0,ic);
  for(i in 1:length(li))
    score[i]=(sum(p[wi[[i]]]));#-sum(p[li[[i]]]));#*(sum(p[li[[i]]])+sum(p[wi[[i]]]));
  return(score)
}
 #This fuction scores items based on their weighted similaity to the losing items of the target user
  #g: reformed shape of LNet constructed by the abov functions 
  #uid: the id of the target user
  #wi: the list of winning side of items in the reformed LNet graph
  #Li: the list of losiing side of items in the reformed LNet graph
  
ranking_looser<-function(g,uid,ic,wi,li,damping=0.85){
  #g=set.vertex.attribute(g,name = "id",1:vcount(g),value = 1:vcount(g));
  #g=g-setdiff(g,which(degree(g)==0));
  r=which(get.vertex.attribute(g,"uid")==uid);
  m=degree(g,r);
  pp=rep(0,vcount(g));
  pp[r]=m/sum(m);
  p=page.rank(g,personalized = pp,damping = damping)$vector;
  score=rep(0,ic);
  for(i in 1:length(li))
    score[i]=(sum(p[li[[i]]]));#-sum(p[li[[i]]]));#*(sum(p[li[[i]]])+sum(p[wi[[i]]]));
  return(score)
}

makeTrList<-function(Rate,ic){
  m=1:max(Rate[,1]);
  tr=array(list(),length(m))
  ts=array(list(),length(m))
  for(i in 1:max(m)){
    sl=which(Rate[,1]==m[i]);
    if(length(sl)>0){
      iuser=Rate[sl,];
      
      tr[[i]]=sparseMatrix(i=as.double(iuser[,2]),j=as.double(iuser[,3]),x=as.double(iuser[,4]),dims=c(ic,ic),use.last.ij = T);
      
      tr[[i]]=drop0(tr[[i]]);
    }
  }
  return( tr);
}
Prep<-function(trs,rmat){
  m=rep(0,length(trs))
  usercount=length(trs);
  for(i in 1:usercount){
    s=trs[[i]]
    if(i%%100==0)
      print(i)
    if(length(s)>1){
      for( uu in 1:(length(s)-1))
        for(hh in (uu+1):length(s)){
          print(c(i,hh,length(s)))
          if(length(s[[uu]])>0&&length(s[[hh]])>0){
            m[i]=m[i]+length(s[[hh]])*length(s[[uu]]);
            if(is.na(m[i])){
              xx="***"
            }
          }
        }
    }
  }
  el=matrix(0,sum(m),4)
  count=1;
  for(i in 1:length(trs)){
    if(i%%1000==0)
      print(i)
    if(m[i]>0){
      v=trs[[i]];
      x=makePrefMat_Ricci(trs = trs[[i]],l =m[i] ,uid = i,trmat = rmat);
      #print(c(i,"h"))
      p=x
      count2=count+m[i]-1
      el[count:(count2),]=p
      count=count2+1;
    }
  }
  return(el)
}
calUserLength<-function(userSeq){
  r=lapply(userSeq, FUN=length)
  r=unlist(r)
  return(r);  
}
makeTrSPlitList<-function(tr,rmat,map){
  x=array(list(),length(tr))
  for(i in 1:length(tr)){
    x[[i]]=splitRating(rmat,i,map[tr[[i]]])
  }
  return(x);
}

makePrefMat_Ricci<-function(trs,l,uid,trmat){
  
  # print(c(uid,l))
  prefMat=matrix(0,l,4);
  count=1
  for(i in 1:(length(trs)-1)){         
    aa=trs[[i]];
    for(j in (i+1):length(trs)){
      bb=trs[[j]];          
      for(a in 1:length(trs[[i]])){
        if(!is.na(trmat[uid,aa[a]])){
          for(b in 1:length(trs[[j]])){    
            if(!is.na(trmat[uid,aa[a]])){
              prefMat[count,]=c(uid,aa[a],bb[b],trmat[uid,aa[a]]-trmat[uid,bb[b]]);
              count=count+1;
              #prefMat[bb[b],aa[a]]=-sign(trmat[uid,bb[b]]-trmat[uid,aa[a]]);
            }
          }
        }
      }
    }
  }
  #prefMat[which(prefMat<0)]=0;
  return(prefMat)
}
