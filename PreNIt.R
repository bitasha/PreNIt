#rmat: rating matrix m*n
#usersequence: a list of array such that  userSeq[[i]] contains items that are rated by i-th user 
#       (is generated by makeUserseq function)

#rl: length of recommendation list (NDCG@rl)
#trl : length of traiing profile of each user (i.e. UPL)
#nl:  length of neighborhood size (typically set to 100)
#direc: the direction of check point recorder 
#trdirec: the direction for training file if available 
#first run : a logic variable to indicate if the evaluation should be initialized or it should be continued based on the check point file
#dampingFactor: the damping factor for graph-based similarity measure
#trainflag:a logical variable to indicate training set  should be generated randomly(0) or load from file(1)
#smet: type of semantic analysis: smet=1: user-based, smet=2: P-ReGRank, smet=3: R-ReGRank

rankEvaluation_Yu_PReNIt<-function(rmat,userSeq,rl=c(1,3,5,10),trl,direc,firstRun,trainflag=0,damping=0.85,trdirec,smet){
  
  userLength= calUserLength(userSeq);
  NDCG=matrix(0,length(trl),length(rl));  
  count=matrix(0,length(trl),length(rl));
  param=c(1,1,0,0)
  tt=0;
  tt2=0;
  if(firstRun==0){
    direcFile=read.csv(direc)
    direcFile=direcFile[,-1]
    param=as.numeric(direcFile[1,]);          st=2;     end=st+length(trl)-1;
    NDCG=data.matrix(direcFile[st:(end),]);     st=end+1; end=st+length(trl)-1;
    count=data.matrix(direcFile[st:end,]);  
    userLength= calUserLength(userSeq); tt=0;
    tt2=param[4];
  }
  
  for(w in param[1]:length(trl)){            
    j=trl[w]
    t=Yu_prepareData(rmat,j+max(rl),userSeq);
    userSeq=t@us;
    rmat=t@rmat2;
    ic=ncol(rmat)
    for(i in param[2]:1){
      #trList and testListindices of user in train and tes
      testSet= 1:nrow(rmat);
      trList=c(1:nrow(rmat));
      tr=trList_random(userSeq,j,testSet); 
      if(trainflag==1){
        x=read.csv(trdirec);x=x[,-1]
        tr=lapply(seq_len(nrow(x)),function(i) as.numeric(x[i,]))
      }else{
        writeTrain(tr,trList,trdirec); 
      }
      trMat=makeTrainMat(tr,rmat);
      
      trs=makeTrSPlitList(tr,trMat,1:ic);
      t333<-system.time(RateCom<-Prep(trs = trs,trMat));
      preftr=makeTrList(RateCom,ncol(rmat));
      t<-system.time(l<-make2LGraph_choiceContexGeneral_Ricci2_itembased_winner(preftr,ic = ic));
      g=graph.edgelist(l[,1:2],directed=F);
      nt=(length(tr)*ic+ic)-vcount(g)
      g=add.vertices(g,nt);
      g=set.vertex.attribute(g,name = "id",1:vcount(g),value = 1:vcount(g));
      
      t<-t+system.time(l2<-make2LGraph_choiceContexGeneral_Ricci2_itembased_looser(preftr,ic = ic));
      g2=graph.edgelist(l2[,1:2],directed=F);
      nt2=(length(tr)*ic+ic)-vcount(g2)
      g2=add.vertices(g2,nt2);
      g2=set.vertex.attribute(g2,name = "id",1:vcount(g2),value = 1:vcount(g2));
      
      uidIndex=rep(0,vcount(g));
      wIndex=rep(0,vcount(g));
      lIndex=rep(0,vcount(g2));
      nr=length(tr);
      for(ind in 1:nr){
        r=((ind-1)*ic+1):(ind*ic)
        uidIndex[r]=ind;
      }
      
      for(ind in 1:ic){
        r=nr*ic+ind
        wIndex[r]=ind;
        lIndex[r]=ind;
      }
      g=set.vertex.attribute(g,"uid",1:vcount(g),uidIndex);
      g=set.vertex.attribute(g,"winner",1:vcount(g),wIndex);
      g=set.vertex.attribute(g,"looser",1:vcount(g),lIndex);
      g2=set.vertex.attribute(g2,"uid",1:vcount(g2),uidIndex);
      g2=set.vertex.attribute(g2,"winner",1:vcount(g2),wIndex);
      g2=set.vertex.attribute(g2,"looser",1:vcount(g2),lIndex);
      
      g1=g;
      g=g-(which(degree(g)==0));
      g2=g2-(which(degree(g2)==0));
      
      wind=get.vertex.attribute(g,"winner",1:vcount(g))
      lind=get.vertex.attribute(g2,"looser",1:vcount(g2))
      uind1=get.vertex.attribute(g,"uid",1:vcount(g))
      uind2=get.vertex.attribute(g2,"uid",1:vcount(g2))
      
      wi=array(list(),ic)
      li=array(list(),ic)
      for(ind in 1:ic){
        wi[[ind]]=which(wind==ind)
        li[[ind]]=which(lind==ind)
      }
     
      
      
      
      for(uid in (param[3]+1):length(testSet)){
        if((uid%%50)==0)
          gc(T);
        tp={};
        for(h in 1:length(tr[[testSet[[uid]]]])){
          tp=c(tp,which(userSeq[[testSet[uid]]]==tr[[uid]][h]))
        }
        ts=userSeq[[testSet[uid]]][-tp];
        
        sh=1;
        
        #tt=tt+system.time(f<-makeGraphMat3L(g,uid,tr,ts ,rmat =rmat));
        if(!is.null(preftr[[uid]])){
          t<-t+system.time(f1<-ranking_winner(g = g,ic = ic,uid = uid,wi = wi,li = li,damping=0.85));    
          t<-t+system.time(f2<-ranking_looser(g = g2,ic = ic,uid = uid,wi = wi,li = li,damping=0.85));  
          #  f2<-ranking_user(g = g3,ic = ic,uid = uid,wi = wi,li = li,damping=0.85); 
          t2<-system.time(f<-f1-f2)
          #f=f1-f2;
        }else{
          f=rep(0,ic);
        }
        #tt2=tt2+system.time(f<-pathrank(trans,id = uid,nrow(rmat),ncol(rmat)));
        
        for(d in 1:length(rl)){
          topK=rl[d];
          r=order(f,decreasing=T);
          r=intersect(r,ts);
          recomList=r[1:topK];
          count[w,d]=count[w,d]+1;
          NDCG[w,d]=NDCG[w,d]+calNDCG(f[ts],rmat[testSet[uid],ts],topK);
        }
          if(uid%%50==0){        
            print(c(uid,NDCG/count))
            checkRes=rbind(c(w,i,uid,tt2[1]),NDCG,count);
            write.csv(checkRes,direc);
          }
      }
      
      checkRes=rbind(c(w,i,uid,tt2[1]),NDCG,count);
      
      write.csv(checkRes,direc);
      
    }
    print("NDCG")
    print(NDCG/count)
    print(c("tt",tt));
    # prec=prec/(count);    
    # reca=reca/(count);
    # NDCG=NDCG/(count);
    
  }    
  
  ev=setClass("ev",slots=c("NDCGALL","count","t1"));
  evt=new("ev",NDCGALL=NDCG/count,count=count,t1=tt2);                        
  return(evt)
}
library(igraph)
pathrank<-function(trans,id,nr,nc){
  trans=t(trans)
  rank=rep(1,nrow(trans))
  rank=rank/sum(rank)
  rank=matrix(rank,length(rank),1);
  p=matrix(0,length(rank),1);
  p[id]=1
  for(i in 1:20){
    rank=0.85*trans%*%matrix(rank,length(rank),1)+0.15*p;
    #rank=(0.85*(crossprod(t(trans),rank)));
    #rank[id,1]=rank[id,1]+0.15;
    #rank=rank/sum(rank);
    #rank=rank+(1-sum(rank))/length(rank);
    rank[id,1]=rank[id,1]+(1-sum(rank));
  }
  l=rank[(length(rank)-2*nc+1):length(rank)]
  v=l[seq(from=1,to=length(l),by=2)]
  v2=l[seq(from=2,to=length(l),by=2)]
  v=v-v2;
  #v=v/(v+v2);
  return(v);
}

make3LGraph_2<-function(rmat,us,testSet,tr,perc=1){
  print("constructing graph")
  #l=matrix(0,ncol(rmat)^2+nrow(rmat),ncol(rmat)^2+nrow(rmat));
  l=rep(0,2);
  count=1
  countp=0;
  t2=matrix(0,5000,2);
  t3=rep(0,2);
  
  for(i in 1:nrow(rmat)){
    uid=i;
    print(uid)
    if(any(testSet==i)){
      r=(tr[[which(testSet==i)]]);
    }
    else{
      r=which(!is.na(rmat[uid,]));
    }    
    s=splitRating(rmat,uid,r);
    m=0;
    if(length(s)>1){
      for( uu in 1:(length(s)-1))
        for(hh in (uu+1):(length(s)))
          m=m+length(s[[hh]])*length(s[[uu]]);
        t2=matrix(0,m,2)
        if((countp%%10000)==0)
          print(i)
        for(j in 1:(length(s)-1)){
          for(k in ((j+1):length(s))){
            if(length(s[[j]])>0&&length(s[[k]])>0){
              t=tList(i,s[[j]],s[[k]],rmat)
              countp=countp+nrow(t);
              tl=count+nrow(t)-1;
              t2[count:tl,]=t;
              count=count+nrow(t);
              
            }
          }
        }    
        
        t3=rbind(t3,t2);   
    }
    count=1;
  }
  if(countp>0){
    print(c(dim(l),dim(t3),dim(t3[-1,])))
    l=rbind(l,t3[-1,]);
  }
  print("L3")
  l=l[-1,]
  st=nrow(rmat)+1;
  end=nrow(rmat)+ncol(rmat)*ncol(rmat);
  u=matrix(0,2*ncol(rmat)*ncol(rmat),2)
  rc=1;
  per=sample(1:nrow(l),floor(perc*nrow(l)))
  l=l[per,]  
  for(k in st:end){
    q=rep(0,2);
    t=ceiling((k-st+1)/ncol(rmat)); #node barande
    t2=(k-st+1)%% ncol(rmat);#node bazande    
    if(t2==0){
      t2=ncol(rmat);
    }
    q=rbind(q,c(k,end+2*t-1));
    q=rbind(q,c(k,end+2*t2));    
    u[rc:(rc+1),]=q[-1,];
    rc=rc+2
  }
  print("graph is constructed")
  l=rbind(l,u)
  return(l);
}
ppr<-function(g, personalized=rep(1/vcount(g),vcount(g)),damping=0.85){
  personalized=personalized/sum(personalized)
  r=(get.adjacency(g));
  e=(drop0(r))
  p=colSums(e);
  e=crossprod(r,solve(Diagonal(x=p)))
  m=personalized
  m=m/sum(m)
  m=matrix(m,length(m),1)
  er=rep(0,100)
  l=which(personalized!=0)
  for(i in 1:20){  
    m2=damping*(e%*%m)+(1-damping)*personalized;
    er[i]=sum((m-m2)^2);
    m=m2
    if(er[i]<0.000001)
      break;
  }
  return(m)
}
#U-REGRank
transformMatrix2_normallAll<-function(g,nr,nc){
  # p=array(list(),length(w)),
  UInd=1:nr;
  PInd=(nr+1):(vcount(g)-2*nc);
  RInd=(vcount(g)-2*nc+1):vcount(g)
  r=get.adjacency(g)
  r=drop0(r);
  rup_1=r[UInd,PInd]
  rpr_1=r[PInd,RInd]
  rAll=t(crossprod((r),solve(Diagonal(x=colSums(r)))))
  rpu=rAll[PInd,UInd]
  rup=rAll[UInd,PInd]
  rpr=rAll[PInd,RInd]
  rrp=rAll[RInd,PInd]
  
  
  #rpu=t(crossprod(t(rup_1),solve(Diagonal(x=colSums(r[PInd,])))))
  #rup=t(crossprod((rup_1),solve(Diagonal(x=colSums(t(rup_1))))))
  #rpr=t(crossprod((rpr_1),solve(Diagonal(x=colSums((r[PInd,]))))))
  #rrp=t(crossprod(t(rpr_1),solve(Diagonal(x=colSums((rpr_1))))))
  
  print("h")
  mp1=rup%*%rpu;
  mp2=rrp%*%rpu;
  mp3=rup%*%rpr;
  print("m")
  smp1=summary(mp1)
  tm1=sparseMatrix(i=smp1[,1],j=smp1[,2],x=smp1[,3],dims=c(vcount(g),vcount(g)))
  smp2=summary(mp2)
  tm2=sparseMatrix(i=RInd[smp2[,1]],j=smp2[,2],x=smp2[,3],dims=c(vcount(g),vcount(g)))
  smp3=summary(mp3)
  tm3=sparseMatrix(i=smp3[,1],j=RInd[smp3[,2]],x=smp3[,3],dims=c(vcount(g),vcount(g)))
  #trans=0.5*tm1+tm2+0.5*tm3
  trans=tm1+tm2+tm3;
  trans=trans[-((nr+1):(ncol(trans)-2*nc)),-((nr+1):(ncol(trans)-2*nc))]
  ss=rowSums(trans)
  print("XXXXX")
  # for(i in 1:nrow(trans))
  #   trans[i,]=trans[i,]/ss[i]
  gc(T)
  v1 <- rowSums(trans)
  trans=as(trans,"matrix")
  trans=prop.table(trans,1)
  print("yyy")
  # for(k in 1:nrow(trans)){
  #   print(k)
  #   trans[k,] <- trans[k,]/v1[k]
  # }
  #trans=sweep(trans,1,rowSums(trans),FUN ="/")
  
  #trans=t(crossprod(t(trans),solve(Diagonal(x=colSums(trans)))))
  x="*"
  return(environment())
}


#P_ReGRank
transformMatrix4_normallAll<-function(g,nr,nc){
  # p=array(list(),length(w)),
  UInd=1:nr;
  PInd=(nr+1):(vcount(g)-2*nc);
  RInd=(vcount(g)-2*nc+1):vcount(g)
  r=get.adjacency(g)
  r=drop0(r);
  rup_1=r[UInd,PInd]
  rpr_1=r[PInd,RInd]
  rAll=t(crossprod((r),solve(Diagonal(x=colSums(r)))))
  rpu=rAll[PInd,UInd]
  rup=rAll[UInd,PInd]
  rpr=rAll[PInd,RInd]
  rrp=rAll[RInd,PInd]
  
  
  #rpu=t(crossprod(t(rup_1),solve(Diagonal(x=colSums(r[PInd,])))))
  #rup=t(crossprod((rup_1),solve(Diagonal(x=colSums(t(rup_1))))))
  #rpr=t(crossprod((rpr_1),solve(Diagonal(x=colSums((r[PInd,]))))))
  #rrp=t(crossprod(t(rpr_1),solve(Diagonal(x=colSums((rpr_1))))))
  
  
  mp1=rup%*%rpu;
  mp2=rrp%*%rpu;
  mp3=rup%*%rpr;
  smp1=summary(mp1)
  tm1=sparseMatrix(i=smp1[,1],j=smp1[,2],x=smp1[,3],dims=c(vcount(g),vcount(g)))
  smp2=summary(mp2)
  tm2=sparseMatrix(i=RInd[smp2[,1]],j=smp2[,2],x=smp2[,3],dims=c(vcount(g),vcount(g)))
  smp3=summary(mp3)
  tm3=sparseMatrix(i=smp3[,1],j=RInd[smp3[,2]],x=smp3[,3],dims=c(vcount(g),vcount(g)))
  #trans=0.5*tm1+tm2+0.5*tm3
  trans=tm1+tm3;
  trans=trans[-((nr+1):(ncol(trans)-2*nc)),-((nr+1):(ncol(trans)-2*nc))]
  ss=rowSums(trans)
  # for(i in 1:nrow(trans))
  #   trans[i,]=trans[i,]/ss[i]
  #trans=sweep(trans,1,rowSums(trans),FUN ="/")
  #v1 <- rowSums(trans)
  #trans <- trans/(v1)
  trans=as(trans,"matrix")
  trans=prop.table(trans,1)
  #trans=t(crossprod(t(trans),solve(Diagonal(x=colSums(trans)))))
  x="*"
  return(environment())
}


#R-REGRank
transformMatrix6_normallAll<-function(g,nr,nc){
  # p=array(list(),length(w)),
  UInd=1:nr;
  PInd=(nr+1):(vcount(g)-2*nc);
  RInd=(vcount(g)-2*nc+1):vcount(g)
  r=get.adjacency(g)
  r=drop0(r);
  rup_1=r[UInd,PInd]
  rpr_1=r[PInd,RInd]
  rAll=t(crossprod((r),solve(Diagonal(x=colSums(r)))))
  rpu=rAll[PInd,UInd]
  rup=rAll[UInd,PInd]
  rpr=rAll[PInd,RInd]
  rrp=rAll[RInd,PInd]
  
  
  #rpu=t(crossprod(t(rup_1),solve(Diagonal(x=colSums(r[PInd,])))))
  #rup=t(crossprod((rup_1),solve(Diagonal(x=colSums(t(rup_1))))))
  #rpr=t(crossprod((rpr_1),solve(Diagonal(x=colSums((r[PInd,]))))))
  #rrp=t(crossprod(t(rpr_1),solve(Diagonal(x=colSums((rpr_1))))))
  
  
  mp1=rup%*%rpu;
  mp2=rrp%*%rpu;
  mp3=rup%*%rpr;
  smp1=summary(mp1)
  tm1=sparseMatrix(i=smp1[,1],j=smp1[,2],x=smp1[,3],dims=c(vcount(g),vcount(g)))
  smp2=summary(mp2)
  tm2=sparseMatrix(i=RInd[smp2[,1]],j=smp2[,2],x=smp2[,3],dims=c(vcount(g),vcount(g)))
  smp3=summary(mp3)
  tm3=sparseMatrix(i=smp3[,1],j=RInd[smp3[,2]],x=smp3[,3],dims=c(vcount(g),vcount(g)))
  #trans=0.5*tm1+tm2+0.5*tm3
  trans=tm2+tm3;
  trans=trans[-((nr+1):(ncol(trans)-2*nc)),-((nr+1):(ncol(trans)-2*nc))]
  ss=rowSums(trans)
  # for(i in 1:nrow(trans))
  #   trans[i,]=trans[i,]/ss[i]
  # trans=sweep(trans,1,rowSums(trans),FUN ="/")
  #v1 <- rowSums(trans)
  #trans <- trans/(v1)
  trans=as(trans,"matrix")
  trans=prop.table(trans,1)
  #trans=t(crossprod(t(trans),solve(Diagonal(x=colSums(trans)))))
  x="*"
  return(environment())
}

make2LGraph_choiceContexGeneral_Ricci2_itembased_winner<-function(tr,ic) {
  print("constructing graph")
  l = rep(0, 2)
  count = 1
  countp = 1
  nr=length(tr)
  t2 = matrix(0, 5000, 2)
  context=array(list(),0)
  m=0;
  for(k in 1:length(tr)){
    if(!is.null(tr[[k]]))
      m=m+floor(1*nrow(summary(tr[[k]])))
  }
  #m=floor(0.2*m)
  l = matrix(0,m,3);
  
  for (k in 1:length(tr)) {
    uid=k
    if(k%%1000==0)
      print(k)
    if(!is.null(tr[[k]])){
      data=summary(tr[[k]]);
      data=data[sample(1:nrow(data),floor(1*nrow(data))),]
      user=k;
      
      t3 = matrix(0,nrow(data),3);
      count=1;
      
      for(i in 1:nrow(data)){
        
        item1=data[i,1];
        item2=data[i,2];
        value=data[i,3];
        if(value<0){
          tmp=item1;
          item1=item2;
          item2=tmp;
          value=-value;
        }
        h1=(uid-1)*ic+item2;
        h2=nr*ic+(item1);
        t3[count,]=c(h1,h2,value)
        #t3[count,]=c(user,item2+nr,item1+nr,-value)
        
        count=count+1
      }
      countp2=(countp+(nrow(data)))-1
      l[(countp:countp2),]=unique(t3)
      countp=countp2+1;
    }
  }
  print("L3")
  #l=unique(t3[,1:4])
  return(l);
}
make2LGraph_choiceContexGeneral_Ricci2_itembased_looser<-function(tr,ic) {
  print("constructing graph")
  l = rep(0, 2)
  count = 1
  countp = 1
  nr=length(tr)
  t2 = matrix(0, 5000, 2)
  context=array(list(),0)
  m=0;
  for(k in 1:length(tr)){
    if(!is.null(tr[[k]]))
      m=m+floor(1*nrow(summary(tr[[k]])))
  }
  #m=1*m;
  l = matrix(0,m,3);
  
  for (k in 1:length(tr)) {
    uid=k
    if(k%%1000==0)
      print(k)
    if(!is.null(tr[[k]])){
      data=summary(tr[[k]]);
      data=data[sample(1:nrow(data),floor(1*nrow(data))),]
      user=k;
      
      t3 = matrix(0,nrow(data),3);
      count=1;
      
      for(i in 1:nrow(data)){
        
        item1=data[i,1];
        item2=data[i,2];
        value=data[i,3];
        if(value<0){
          tmp=item1;
          item1=item2;
          item2=tmp;
          value=-value;
        }
        h1=(uid-1)*ic+item1;
        h2=nr*ic+(item2);
        t3[count,]=c(h1,h2,value)
        #t3[count,]=c(user,item2+nr,item1+nr,-value)
        
        count=count+1
      }
      countp2=(countp+(nrow(data)))-1
      l[(countp:countp2),]=unique(t3)
      countp=countp2+1;
    }
  }
  print("L3")
  #l=unique(t3[,1:4])
  return(l);
}
ranking_winner<-function(g,uid,ic,wi,li,damping=0.85){
  #g=set.vertex.attribute(g,name = "id",1:vcount(g),value = 1:vcount(g));
  #g=g-setdiff(g,which(degree(g)==0));
  r=which(get.vertex.attribute(g,"uid")==uid);
  m=degree(g,r);
  pp=rep(0,vcount(g));
  pp[r]=m/sum(m);
  p=page.rank(g,personalized = pp,damping = damping)$vector;
  score=rep(0,ic);
  for(i in 1:length(li))
    score[i]=(sum(p[wi[[i]]]));#-sum(p[li[[i]]]));#*(sum(p[li[[i]]])+sum(p[wi[[i]]]));
  return(score)
}
ranking_looser<-function(g,uid,ic,wi,li,damping=0.85){
  #g=set.vertex.attribute(g,name = "id",1:vcount(g),value = 1:vcount(g));
  #g=g-setdiff(g,which(degree(g)==0));
  r=which(get.vertex.attribute(g,"uid")==uid);
  m=degree(g,r);
  pp=rep(0,vcount(g));
  pp[r]=m/sum(m);
  p=page.rank(g,personalized = pp,damping = damping)$vector;
  score=rep(0,ic);
  for(i in 1:length(li))
    score[i]=(sum(p[li[[i]]]));#-sum(p[li[[i]]]));#*(sum(p[li[[i]]])+sum(p[wi[[i]]]));
  return(score)
}

makeTrList<-function(Rate,ic){
  m=1:max(Rate[,1]);
  tr=array(list(),length(m))
  ts=array(list(),length(m))
  for(i in 1:max(m)){
    sl=which(Rate[,1]==m[i]);
    if(length(sl)>0){
      iuser=Rate[sl,];
      # print(c(i,"v",length(sl)))
      #iuser2=iuser;
      #iuser=iuser[,c(1,3,2,4)];
      #print(i,sl,)
      #iuser[,4]=-iuser[,4];
      #iuser=rbind(as.matrix(iuser),as.matrix(iuser2));
      #ll=which(iuser[,2]>iuser[,3])
      #iuser[ll,]=ius
      tr[[i]]=sparseMatrix(i=as.double(iuser[,2]),j=as.double(iuser[,3]),x=as.double(iuser[,4]),dims=c(ic,ic),use.last.ij = T);
      
      tr[[i]]=drop0(tr[[i]]);
    }
  }
  return( tr);
}
Prep<-function(trs,rmat){
  m=rep(0,length(trs))
  usercount=length(trs);
  for(i in 1:usercount){
    s=trs[[i]]
    if(i%%100==0)
      print(i)
    if(length(s)>1){
      for( uu in 1:(length(s)-1))
        for(hh in (uu+1):length(s)){
          print(c(i,hh,length(s)))
          if(length(s[[uu]])>0&&length(s[[hh]])>0){
            m[i]=m[i]+length(s[[hh]])*length(s[[uu]]);
            if(is.na(m[i])){
              xx="***"
            }
          }
        }
    }
  }
  el=matrix(0,sum(m),4)
  count=1;
  for(i in 1:length(trs)){
    if(i%%1000==0)
      print(i)
    if(m[i]>0){
      v=trs[[i]];
      x=makePrefMat_Ricci(trs = trs[[i]],l =m[i] ,uid = i,trmat = rmat);
      #print(c(i,"h"))
      p=x
      count2=count+m[i]-1
      el[count:(count2),]=p
      count=count2+1;
    }
  }
  return(el)
}
calUserLength<-function(userSeq){
  r=lapply(userSeq, FUN=length)
  r=unlist(r)
  return(r);  
}
makeTrSPlitList<-function(tr,rmat,map){
  x=array(list(),length(tr))
  for(i in 1:length(tr)){
    x[[i]]=splitRating(rmat,i,map[tr[[i]]])
  }
  return(x);
}

makePrefMat_Ricci<-function(trs,l,uid,trmat){
  
  # print(c(uid,l))
  prefMat=matrix(0,l,4);
  count=1
  for(i in 1:(length(trs)-1)){         
    aa=trs[[i]];
    for(j in (i+1):length(trs)){
      bb=trs[[j]];          
      for(a in 1:length(trs[[i]])){
        if(!is.na(trmat[uid,aa[a]])){
          for(b in 1:length(trs[[j]])){    
            if(!is.na(trmat[uid,aa[a]])){
              prefMat[count,]=c(uid,aa[a],bb[b],trmat[uid,aa[a]]-trmat[uid,bb[b]]);
              count=count+1;
              #prefMat[bb[b],aa[a]]=-sign(trmat[uid,bb[b]]-trmat[uid,aa[a]]);
            }
          }
        }
      }
    }
  }
  #prefMat[which(prefMat<0)]=0;
  return(prefMat)
}
